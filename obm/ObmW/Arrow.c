/* Generated by wbuild from "Arrow.w"
** (generator version $Revision: 2.0 $ of $Date: 93/07/06 16:08:04 $)
*/
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#include "stip4.bm"
#include <stdio.h>
#include <assert.h>
#include "ArrowP.h"
static void activate_and_start_timer(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
static void stop_timer(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);

static XtActionsRec actionsList[] = {
{"activate_and_start_timer", activate_and_start_timer},
{"stop_timer", stop_timer},
};

static char defaultTranslations[] = "\
<Btn1Down>: activate_and_start_timer() \n\
<Btn1Up>: stop_timer() \n\
";
static void _resolve_inheritance(
#if NeedFunctionPrototypes
WidgetClass
#endif
);
static void initialize(
#if NeedFunctionPrototypes
Widget ,Widget,ArgList ,Cardinal *
#endif
);
static Boolean  set_values(
#if NeedFunctionPrototypes
Widget ,Widget ,Widget,ArgList ,Cardinal *
#endif
);
static void expose(
#if NeedFunctionPrototypes
Widget,XEvent *,Region 
#endif
);
static void timer_callback(
#if NeedFunctionPrototypes
XtPointer ,XtIntervalId *
#endif
);
static void create_arrowgc(
#if NeedFunctionPrototypes
Widget
#endif
);
static void create_arrowlightgc(
#if NeedFunctionPrototypes
Widget
#endif
);
static void create_arrowdarkgc(
#if NeedFunctionPrototypes
Widget
#endif
);
/*ARGSUSED*/static void timer_callback(client_data,timer)XtPointer  client_data;XtIntervalId * timer;
{
    Widget self = (Widget) client_data;

    XtCallCallbackList(self, ((XfwfArrowWidget)self)->xfwfArrow.callback, NULL);
    ((XfwfArrowWidget)self)->xfwfArrow.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
			     ((XfwfArrowWidget)self)->xfwfArrow.repeatDelay, timer_callback, self);
}
/*ARGSUSED*/static void create_arrowgc(self)Widget self;
{
    XtGCMask mask;
    XGCValues values;

    if (((XfwfArrowWidget)self)->xfwfArrow.arrowgc != NULL) XtReleaseGC(self, ((XfwfArrowWidget)self)->xfwfArrow.arrowgc);
    mask = GCForeground;
    values.foreground = ((XfwfArrowWidget)self)->xfwfArrow.foreground;
    ((XfwfArrowWidget)self)->xfwfArrow.arrowgc = XtGetGC(self, mask, &values);
}
/*ARGSUSED*/static void create_arrowlightgc(self)Widget self;
{
    XtGCMask mask;
    XGCValues values;

    if (((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc != NULL) XtReleaseGC(self, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc);
    switch (((XfwfArrowWidget)self)->xfwfFrame.shadowScheme) {
    case XfwfColor:
	mask = GCForeground;
	values.foreground = ((XfwfArrowWidget)self)->xfwfFrame.topShadowColor;
	break;
    case XfwfStipple:
	mask = GCFillStyle | GCStipple | GCForeground | GCBackground;
	values.fill_style = FillOpaqueStippled;
	values.background = ((XfwfArrowWidget)self)->core.background_pixel;
	values.stipple = ((XfwfArrowWidget)self)->xfwfFrame.topShadowStipple;
	values.foreground = WhitePixelOfScreen(XtScreen(self));
	break;
    case XfwfAuto:
	if (DefaultDepthOfScreen(XtScreen(self)) > 4
	    && ((XfwfArrowWidgetClass)self->core.widget_class)->xfwfCommon_class.lighter_color(self, ((XfwfArrowWidget)self)->xfwfArrow.foreground, &values.foreground)) {
	    mask = GCForeground;
	} else {
	    mask = GCFillStyle | GCBackground | GCForeground | GCStipple;
	    values.fill_style = FillOpaqueStippled;
	    values.background = ((XfwfArrowWidget)self)->xfwfArrow.foreground;
	    values.foreground = WhitePixelOfScreen(XtScreen(self));
	    values.stipple =
		XCreateBitmapFromData(XtDisplay(self),
				      RootWindowOfScreen(XtScreen(self)),
				      stip4_bits, stip4_width, stip4_height);
	}
	break;
    }
    ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc = XtGetGC(self, mask, &values);
}
/*ARGSUSED*/static void create_arrowdarkgc(self)Widget self;
{
    XtGCMask mask;
    XGCValues values;

    if (((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc != NULL) XtReleaseGC(self, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc);
    switch (((XfwfArrowWidget)self)->xfwfFrame.shadowScheme) {
    case XfwfColor:
	mask = GCForeground;
	values.foreground = ((XfwfArrowWidget)self)->xfwfFrame.bottomShadowColor;
	break;
    case XfwfStipple:
	mask = GCFillStyle | GCStipple | GCForeground | GCBackground;
	values.fill_style = FillOpaqueStippled;
	values.stipple = ((XfwfArrowWidget)self)->xfwfFrame.bottomShadowStipple;
	values.foreground = BlackPixelOfScreen(XtScreen(self));
	values.background = ((XfwfArrowWidget)self)->core.background_pixel;
	break;
    case XfwfAuto:
	if (DefaultDepthOfScreen(XtScreen(self)) > 4
	    && ((XfwfArrowWidgetClass)self->core.widget_class)->xfwfCommon_class.darker_color(self, ((XfwfArrowWidget)self)->xfwfArrow.foreground, &values.foreground)) {
	    mask = GCForeground;
	} else {
	    mask = GCFillStyle | GCBackground | GCForeground | GCStipple;
	    values.fill_style = FillOpaqueStippled;
	    values.background = ((XfwfArrowWidget)self)->xfwfArrow.foreground;
	    values.foreground = WhitePixelOfScreen(XtScreen(self));
	    values.stipple =
		XCreateBitmapFromData(XtDisplay(self),
				      RootWindowOfScreen(XtScreen(self)),
				      stip4_bits, stip4_width, stip4_height);
	}
	break;
    }
    ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc = XtGetGC(self, mask, &values);
}

static XtResource resources[] = {
{XtNdirection,XtCDirection,XtRAlignment,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.direction),XtOffsetOf(XfwfArrowRec,xfwfArrow.direction),XtRImmediate,(XtPointer)XfwfTop },
{XtNforeground,XtCForeground,XtRPixel,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.foreground),XtOffsetOf(XfwfArrowRec,xfwfArrow.foreground),XtRString,(XtPointer)XtDefaultBackground },
{XtNarrowShadow,XtCArrowShadow,XtRDimension,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.arrowShadow),XtOffsetOf(XfwfArrowRec,xfwfArrow.arrowShadow),XtRImmediate,(XtPointer)2 },
{XtNinitialDelay,XtCInitialDelay,XtRCardinal,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.initialDelay),XtOffsetOf(XfwfArrowRec,xfwfArrow.initialDelay),XtRImmediate,(XtPointer)500 },
{XtNrepeatDelay,XtCRepeatDelay,XtRCardinal,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.repeatDelay),XtOffsetOf(XfwfArrowRec,xfwfArrow.repeatDelay),XtRImmediate,(XtPointer)200 },
{XtNcallback,XtCCallback,XtRCallback,sizeof(((XfwfArrowRec*)NULL)->xfwfArrow.callback),XtOffsetOf(XfwfArrowRec,xfwfArrow.callback),XtRImmediate,(XtPointer)NULL },
};

XfwfArrowClassRec xfwfArrowClassRec = {
{ /* core_class part */
(WidgetClass) &xfwfBoardClassRec,
"Arrow",
sizeof(XfwfArrowRec),
NULL,
_resolve_inheritance,
FALSE,
initialize,
NULL,
XtInheritRealize,
actionsList,
2,
resources,
6,
NULLQUARK,
False ,
FALSE ,
False ,
False ,
NULL,
XtInheritResize,
expose,
set_values,
NULL,
XtInheritSetValuesAlmost,
NULL,
XtInheritAcceptFocus,
XtVersion,
NULL,
defaultTranslations,
XtInheritQueryGeometry,
XtInheritDisplayAccelerator,
NULL 
},
{ /* composite_class part */
XtInheritGeometryManager,
XtInheritChangeManaged,
XtInheritInsertChild,
XtInheritDeleteChild,
NULL
},
{ /* XfwfCommon_class part */
XtInherit_compute_inside,
XtInherit_highlight_border,
XtInherit_unhighlight_border,
XtInherit_would_accept_focus,
XtInherit_traverse,
XtInherit_choose_color,
XtInherit_lighter_color,
XtInherit_darker_color,
NULL ,
},
{ /* XfwfFrame_class part */
0
},
{ /* XfwfBoard_class part */
XtInherit_set_abs_location,
},
{ /* XfwfArrow_class part */
0
},
};
WidgetClass xfwfArrowWidgetClass = (WidgetClass) &xfwfArrowClassRec;
/*ARGSUSED*/
static void activate_and_start_timer(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    if (event->type != ButtonPress) {
        XtWarning("The Arrow activate action isn't bound to a BtnDown event");
	return;
    }
    XtCallCallbackList(self, ((XfwfArrowWidget)self)->xfwfArrow.callback, NULL);
    ((XfwfArrowWidget)self)->xfwfArrow.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
			     ((XfwfArrowWidget)self)->xfwfArrow.initialDelay, timer_callback, self);
}

/*ARGSUSED*/
static void stop_timer(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    XtRemoveTimeOut(((XfwfArrowWidget)self)->xfwfArrow.timer);
}

static void _resolve_inheritance(class)
WidgetClass class;
{
  XfwfArrowWidgetClass c = (XfwfArrowWidgetClass) class;
  XfwfArrowWidgetClass super;
  static CompositeClassExtensionRec extension_rec = {
    NULL, NULLQUARK, XtCompositeExtensionVersion,
    sizeof(CompositeClassExtensionRec), True};
  CompositeClassExtensionRec *ext;
  ext = (XtPointer)XtMalloc(sizeof(*ext));
  *ext = extension_rec;
  ext->next_extension = c->composite_class.extension;
  c->composite_class.extension = ext;
  if (class == xfwfArrowWidgetClass) return;
  super = (XfwfArrowWidgetClass)class->core_class.superclass;
}
/*ARGSUSED*/static void initialize(request,self,args,num_args)Widget  request;Widget self;ArgList  args;Cardinal * num_args;
{
    if (((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfTop && ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfLeft
	&& ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfRight && ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfBottom) {
	XtWarning("direction of Arrow widget incorrect; set to `top'");
	((XfwfArrowWidget)self)->xfwfArrow.direction = XfwfTop;
    }
    ((XfwfArrowWidget)self)->xfwfArrow.arrowgc = NULL; create_arrowgc(self);
    ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc = NULL; create_arrowlightgc(self);
    ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc = NULL; create_arrowdarkgc(self);
}
/*ARGSUSED*/static Boolean  set_values(old,request,self,args,num_args)Widget  old;Widget  request;Widget self;ArgList  args;Cardinal * num_args;
{
    Boolean need_redisplay = False;

    if (((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfTop && ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfLeft
	&& ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfRight && ((XfwfArrowWidget)self)->xfwfArrow.direction != XfwfBottom) {
	XtWarning("direction of Arrow widget incorrect; set to `top'");
	((XfwfArrowWidget)self)->xfwfArrow.direction = XfwfTop;
    }
    if (((XfwfArrowWidget)old)->xfwfArrow.direction != ((XfwfArrowWidget)self)->xfwfArrow.direction)
	need_redisplay = True;
    if (((XfwfArrowWidget)old)->xfwfArrow.foreground != ((XfwfArrowWidget)self)->xfwfArrow.foreground) {
	create_arrowgc(self);
	need_redisplay = True;
    }
    if (((XfwfArrowWidget)old)->xfwfArrow.arrowShadow != ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow)
	need_redisplay = True;
    if (((XfwfArrowWidget)self)->xfwfFrame.shadowScheme != ((XfwfArrowWidget)old)->xfwfFrame.shadowScheme) {
	create_arrowdarkgc(self);
	create_arrowlightgc(self);
	need_redisplay = True;
    } else if (((XfwfArrowWidget)self)->xfwfFrame.shadowScheme == XfwfColor) {
	if (((XfwfArrowWidget)self)->xfwfFrame.topShadowColor != ((XfwfArrowWidget)old)->xfwfFrame.topShadowColor) {
	    create_arrowlightgc(self);
	    need_redisplay = True;
	}
	if (((XfwfArrowWidget)self)->xfwfFrame.bottomShadowColor != ((XfwfArrowWidget)old)->xfwfFrame.bottomShadowColor) {
	    create_arrowdarkgc(self);
	    need_redisplay = True;
	}
    } else if (((XfwfArrowWidget)self)->xfwfFrame.shadowScheme = XfwfStipple) {
	if (((XfwfArrowWidget)self)->xfwfFrame.topShadowStipple != ((XfwfArrowWidget)old)->xfwfFrame.topShadowStipple) {
	    create_arrowlightgc(self);
	    need_redisplay = True;
	}
	if (((XfwfArrowWidget)self)->xfwfFrame.bottomShadowStipple != ((XfwfArrowWidget)old)->xfwfFrame.bottomShadowStipple) {
	    create_arrowdarkgc(self);
	    need_redisplay = True;
	}
    }
    return need_redisplay;
}
/*ARGSUSED*/static void expose(self,event,region)Widget self;XEvent * event;Region  region;
{
    XPoint p1[3], p2[4], p3[4], p4[4];
    Position x, y;
    Dimension width, height, a, a2, a3;

    assert(((XfwfArrowWidget)self)->xfwfArrow.direction == XfwfTop || ((XfwfArrowWidget)self)->xfwfArrow.direction == XfwfLeft
	   || ((XfwfArrowWidget)self)->xfwfArrow.direction == XfwfRight || ((XfwfArrowWidget)self)->xfwfArrow.direction == XfwfBottom);

    if (! XtIsRealized(self)) return;
    if (region != NULL) {
	XSetRegion(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, region);
	XSetRegion(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, region);
	XSetRegion(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, region);
    }
    ((XfwfArrowWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, &x, &y, &width, &height);
    a = ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow;
    switch (((XfwfArrowWidget)self)->xfwfArrow.direction) {
    case XfwfTop:
	a2 = (1.0 + 0.71*width/height) * a;
	a3 = (1.0 + 0.83*height/width) * a;
	point(p1, 0, x + width/2,	y + a3);
	point(p1, 1, x + a2,		y + height - a);
	point(p1, 2, x + width - a2,	y + height - a);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, p1, 3, Convex,
		     CoordModeOrigin);
	if (a == 0) break;
	point(p2, 0, x + width/2,	y);
	point(p2, 1, x + width/2,	y + a3);
	point(p2, 2, x + width - a2,	y + height - a);
	point(p2, 3, x + width,		y + height);

	point(p3, 0, x + a2,		y + height - a);
	point(p3, 1, x,			y + height);
	point(p3, 2, x + width,		y + height);
	point(p3, 3, x + width - a2,	y + height - a);

	point(p4, 0, x + width/2,	y);
	point(p4, 1, x,			y + height);
	point(p4, 2, x + a2,		y + height - a);
	point(p4, 3, x + width/2,	y + a3);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p2, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p3, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p4, 4, Convex,
		     CoordModeOrigin);
	break;
    case XfwfLeft:
	a2 = (1.0 + 0.83*width/height) * a;
	a3 = (1.0 + 0.71*height/width) * a;
	point(p1, 0, x + a2,		y + height/2);
	point(p1, 1, x + width - a,	y + a3);
	point(p1, 2, x + width - a,	y + height - a3);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, p1, 3, Convex,
		     CoordModeOrigin);
	if (((XfwfArrowWidget)self)->xfwfArrow.arrowShadow == 0) break;
	point(p2, 0, x + width,		y);
	point(p2, 1, x,			y + height/2);
	point(p2, 2, x + a2,		y + height/2);
	point(p2, 3, x + width - a,	y + a3);

	point(p3, 0, x,			y + height/2);
	point(p3, 1, x + width,		y + height);
	point(p3, 2, x + width - a,	y + height - a3);
	point(p3, 3, x + a2,		y + height/2);

	point(p4, 0, x + width,		y);
	point(p4, 1, x + width - a,	y + a3);
	point(p4, 2, x + width - a,	y + height - a3);
	point(p4, 3, x + width,		y + height);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p2, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p3, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p4, 4, Convex,
		     CoordModeOrigin);
	break;
    case XfwfBottom:
	a2 = (1.0 + 0.71*width/height) * a;
	a3 = (1.0 + 0.83*height/width) * a;
	point(p1, 0, x + width/2,	y + height - a3);
	point(p1, 1, x + a2,		y + a);
	point(p1, 2, x + width - a2,	y + a);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, p1, 3, Convex,
		     CoordModeOrigin);
	if (((XfwfArrowWidget)self)->xfwfArrow.arrowShadow == 0) break;
	point(p2, 0, x,			y);
	point(p2, 1, x + width/2,	y + height);
	point(p2, 2, x + width/2,	y + height - a3);
	point(p2, 3, x + a2,		y + a);

	point(p3, 0, x + width,		y);
	point(p3, 1, x + width - a2,	y + a);
	point(p3, 2, x + width/2,	y + height - a3);
	point(p3, 3, x + width/2,	y + height);

	point(p4, 0, x,			y);
	point(p4, 1, x + a2,		y + a);
	point(p4, 2, x + width - a2,	y + a);
	point(p4, 3, x + width,		y);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p2, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p3, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p4, 4, Convex,
		     CoordModeOrigin);
	break;
    case XfwfRight:
	a2 = (1.0 + 0.83*width/height) * a;
	a3 = (1.0 + 0.71*height/width) * a;
	point(p1, 0, x + width - ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow,	y + height/2);
	point(p1, 1, x + ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow,		y + ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow);
	point(p1, 2, x + ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow,		y + height - ((XfwfArrowWidget)self)->xfwfArrow.arrowShadow);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, p1, 3, Convex,
		     CoordModeOrigin);
	if (((XfwfArrowWidget)self)->xfwfArrow.arrowShadow == 0) break;
	point(p2, 0, x,			y + height);
	point(p2, 1, x + width,		y + height/2);
	point(p2, 2, x + width - a2,	y + height/2);
	point(p2, 3, x + a,		y + height - a3);

	point(p3, 0, x,			y);
	point(p3, 1, x + a,		y + a3);
	point(p3, 2, x + width - a2,	y + height/2);
	point(p3, 3, x + width,		y + height/2);

	point(p4, 0, x,			y);
	point(p4, 1, x,			y + height);
	point(p4, 2, x + a,		y + height - a3);
	point(p4, 3, x + a,		y + a3);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, p2, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p3, 4, Convex,
		     CoordModeOrigin);
	XFillPolygon(XtDisplay(self), ((XfwfArrowWidget)self)->core.window, ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, p4, 4, Convex,
		     CoordModeOrigin);
	break;
    }
    if (region != NULL) {
	XSetClipMask(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowgc, None);
	XSetClipMask(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowlightgc, None);
	XSetClipMask(XtDisplay(self), ((XfwfArrowWidget)self)->xfwfArrow.arrowdarkgc, None);
    }
}
